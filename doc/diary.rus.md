*Начало*

Моя мотивация была простая. Во-первых, Mozilla обещала общее API создания расширений с Хромом. Во-вторых, вместе с удалением старых API должны были отвалиться несколько старых прилоежний, которыми я пользуюсь. Наконец, мне просто надоел мой каталог ссылок. Он жутко неудочный. Надо вручную вставлять имя и адрес странички, затем вручную сохранять файл и копировать его в нужное место. И я соблазнился сделать расширение для Firefox. Это был первый и последний раз. 

*Хранилище данных*

Первым делом мне понадобилось хранилище данных. Я думал использовать обычные файлы. 

1. Нельзя работать с файлами, нельзя читать и писать файлы из расширений. Дескать это приводит к жутким проблемам с безопасностью. Хотя в Хром это работает. 

2. Вместо этого пределагается runtime.storage, гибридный урод, плод богомерзкой связи между IndexedDB и localStorage. Он также сохраняет по ключам любую информацию, не только текст, совместимую с JSON. Но работает асинхронно. То есть после выполнения get, вы получаете в ответ promise, которому надо передать обычную функцию-обратку и ждать, пока она выполнится. В неё уже приходят извлечённые данные.

3. Обёртка данных. Когда вы ложите данные в storage по ключу, они заворачиваются в анонимный объект

set({key:value})

когда вы получаете данные по ключу, вы получаете этот самый анонимый объект

get(key).then( data => {key:value})

Нет слов,чтобы описать,сколько нервов я потратил на эту херню. 

4. В качестве ключа идёт ИМЯ, а не значение переменной, даже если это строка. Поэтому если у вас такой код

key = "fish"

storage.set({key: "pussy"})

то запишется и прочитатся 

{
    "key": "pussy"
}


Чтобы обойти проблему, надо превратить имя переменной в строку, т.е. присвоить его объекту


var obj = {key:"pussy"}

storage.set(obj);

Отвратительно.

5. Оказкалось, что хранилище удобно использовать для связи между вкладками и разными частями рашсирешния. Кто бы мог подумать.



*Открытие вкладок*

К счастью, Firefox позволяет открывать вкладки. Он, правда, делает ограничения для привилегированных вкладок, и для страниц, лежащих в самом расшиернии. Ну у меня там лежит страничка dialog.html. Я хочу её открыть во вкладке. Это всё-таки можно сделать.

Однако есть нюанс. Метод create возвращаеет promise, которое срабатывает, когда вклдака открывается. Но открывается она до того, как в неё загрузится html, css и скрипты! То есть это пустая вкладка! Имено это делает открытие вкладок бесполезным. 

*Передача данных*

Итак, ура, я нашёл активную вкладку, прочёл её адрес и заголовок. Я открыл вкладку с диалогом добавления ссылки. Теперь надо передать в неё информацию, а именно адрес и заголовок добавляемой страницы. 

К сожалению, сделать это невозможно. Кроме как использовать внедряемый скрипт. 

tabs.executeScript()

You can only inject code into pages whose URL can be expressed using a match pattern: meaning, its scheme must be one of "http", "https", "file", "ftp". This means that you can't inject code into any of the browser's built-in pages, such as about:debugging, about:addons, or the page that opens when you open a new empty tab. 

*Связи между вкладками, фоновыми скриптами и частями расширения*

О, как легко мне будет работать! Я беру активную вкладку, получаю из неё адрес и заголовок, открываю новую вкладку, делаю её активной, передаю в неё адрес и заголовок и спрашиваю, добавить ли в базу данных? 

Нет простого способа передать данные во вновь открытую вкладку. 

Я думал, можно использовать метод внедрения скрипта. Оказалось, это запрещено в целях безопаности. Это можно сделать только с вкладками, которые получаются из интернета, но не с привилегированными и открытыми самим прилоежнием. 

*Сообщения*

Тогда я испробовал метод отправки сообщения. Но и тут был облом. Firefox выдал мне ошибку 
firefox sendmessage Error: Could not establish connection. Receiving end does not exist.
Error: Could not establish connection. Receiving end does not exist.

Неужели причиной стало то, что приёмник сообщения не успевал создаваться до того, как сообщение было отправлено? Но разве такое возможно? Почему бы вообще не вести очередь сообщений?

Или приёмник не находится в контексте "фонового" background скрипта, а находится в контексте страничного, внедрённого скрипта. Поэтому он не может принимать сообщения. Так что ли? Но это же чепуха. Принимать сообщения может и страничный, и фоновый скрипт.

Это навело меня на мысль, создать сразу в самом начале фонового скрипта приёмник для любых сообщений, посланных runtime.postMessage,а потом распределять их куда надо. Но вопрос. Как распределять?

Вот вменяемый ответ с stackoverflow

You get the error:

Error: Could not establish connection. Receiving end does not exist.

when you attempt to communicate (e.g. tabs.sendMessage(), tabs.connect()) to a tab where a content script is not listening for messages. This includes times when a content script does not exist in the tab.

То есть посылать сообщение в открытую вкладку - бессмысленно. Надо ждать, когда она загрузится, и тогда... Значит, надо принимать сообщение? 



*Порты*

Это чуть более продвинутая схема с сообщениями. Порты бывыют двух видов - активные и пассивные. Активные просто создаются browser.runtime и отправляют сообщения всем на свете. Пассивные создаются не так. Сперва создаётся слушатель сообщения onConnect. В него поступает порт. Я понятия не имею это тот же самые активный порт, мною созданный или другой, его копия. 

Адресация выполняется с помощью имени port.name. Слушатель события onConnect должен проверить, нужный ли ему порт и... работать с ним или не работать дальше. Никакой функции reject не существует. 

Отлаживать порты трудно, поскольку не существует инструмента, где можно посмотреть список портов и ожидателей связи с ними. 

После того, как связи установлены, порты могут обмениваться сообщениями. При этом активный и пассивный порт могут принимать и посылать соощения. 

Как было сказано выше, tabs.connect(id) не работает именно потому, что хотя вклдака уже и создана и активна, в ней не создано содержимое, не загружены скрипты и не созданы слушатели сообщеий. Поэтому связи с только что открытыми вкладками приходится обращать в обатную сторону. Фоновый скрипт ждёт сообщений от них, а не наоборот. 

Я так и не понял этой системы до конца. Как ведёт себя система, когда портов множество, когда несколько из них имеют одинаковое имя, ибо предназначены для связи с одним и тем же скриптом из других скриптов? Это одна из самых худших систем сообщений в индустрии.

*Совместимость с хром*

Разногласий 2: 

в хроме вместо browser используется chrome и вместо дурацких promise используют обычные функции-обратки. Есть и ещё какие-то мелочи. 

Имееется webextension-polyfill, который вроде как решает эту проблему, добавляя promise в  объекты Chrome. Но он работает через пень колоду. Мне было проще написать библиотеку (framework), которая обёртывает объекты и там, внтури одной-двух функций написать разные варианты для обеих систем. 


* Вкладки * 

ID вкладки зачастую строка, хотя функции, управляющие вкладками принимают число. 

Оно может меняться произвольным образом. Для слежения за ним необходимо слушать событие onUpdate. Оно одинаково во всех браузеах. Слушатель получает новое Id, объект с изменёнными свойствами и старый объект, включающий старое id. 

tabs.onUpdated

chrome.tabs.onUpdated.addListener(function callback)

callback (integer tabId, object changeInfo, Tab tab)


* VUE *

окончательно задолбал. А сначала казался почти таким же хорошим, как Дельфи. Да, с его помощью легко набросать простенький код. Но потом всё равно требуется вводить webpack. И, да,сложные вещи проще писать вручную на pure Javascript или его подобии JSX. Наш Vue умеет делать и последнее, но это воплощено в реальность столь геморроидальным способом, что проще сразу использовать React. 

Задолбало же меня созерцание неработающих шаблонов и чистых сообщений об ошибках. Возможно, причина в использованиии сжатой версии библиотеки, но я не уверен. 


* CSP - Content Security Police *

Это была последняя пуля. Штука, которая запрещает выполнение "опасных" eval, new Function (конструкторов функций), то есть вещей, которые позволяют на лету генерировать код. А также все виды таймеров. Все эти вещи есть в любой библиотеке, на них строится каждый шаблонизатор. 

script-src 'self' 'unsafe-evel'

Директива должна разрешать генерацию кода как источник скриптов. Но! Есть нюанс с понятием self. Он означает не всё расширение. Он означает только файлы html, включённые в расширение, а также фоновую страницу. Да, каждый по отдельности есть self. И это разные self.