*Начало*

Моя мотивация была простая. Во-первых, Mozilla обещала общее API создания расширений с Хромом. Во-вторых, вместе с удалением старых API должны были отвалиться несколько старых прилоежний, которыми я пользуюсь. Наконец, мне просто надоел мой каталог ссылок. Он жутко неудочный. Надо вручную вставлять имя и адрес странички, затем вручную сохранять файл и копировать его в нужное место. И я соблазнился сделать расширение для Firefox. Это был первый и последний раз. 

*Хранилище данных*

Первым делом мне понадобилось хранилище данных. Я думал использовать обычные файлы. 

1. Нельзя работать с файлами, нельзя читать и писать файлы из расширений. Дескать это приводит к жутким проблемам с безопасностью. Хотя в Хром это работает. 

2. Вместо этого пределагается runtime.storage, гибридный урод, плод богомерзкой связи между IndexedDB и localStorage. Он также сохраняет по ключам любую информацию, не только текст, совместимую с JSON. Но работает асинхронно. То есть после выполнения get, вы получаете в ответ promise, которому надо передать обычную функцию-обратку и ждать, пока она выполнится. В неё уже приходят извлечённые данные.

3. Обёртка данных. Когда вы ложите данные в storage по ключу, они заворачиваются в анонимный объект

set({key:value})

когда вы получаете данные по ключу, вы получаете этот самый анонимый объект

get(key).then( data => {key:value})

Нет слов,чтобы описать,сколько нервов я потратил на эту херню. 

4. В качестве ключа идёт ИМЯ, а не значение переменной, даже если это строка. Поэтому если у вас такой код

key = "fish"

storage.set({key: "pussy"})

то запишется и прочитатся 

{
    "key": "pussy"
}


Чтобы обойти проблему, надо превратить имя переменной в строку, т.е. присвоить его объекту


var obj = {key:"pussy"}

storage.set(obj);

Отвратительно.

5. Оказкалось, что хранилище удобно использовать для связи между вкладками и разными частями рашсирешния. Кто бы мог подумать.



*Открытие вкладок*

К счастью, Firefox позволяет открывать вкладки. Он, правда, делает ограничения для привилегированных вкладок, и для страниц, лежащих в самом расшиернии. Ну у меня там лежит страничка dialog.html. Я хочу её открыть во вкладке. Это всё-таки можно сделать.

Однако есть нюанс. Метод create возвращаеет promise, которое срабатывает, когда вклдака открывается. Но открывается она до того, как в неё загрузится html, css и скрипты! То есть это пустая вкладка! Имено это делает открытие вкладок бесполезным. 

*Передача данных*

Итак, ура, я нашёл активную вкладку, прочёл её адрес и заголовок. Я открыл вкладку с диалогом добавления ссылки. Теперь надо передать в неё информацию, а именно адрес и заголовок добавляемой страницы. 

К сожалению, сделать это невозможно. Кроме как использовать внедряемый скрипт. 

tabs.executeScript()

You can only inject code into pages whose URL can be expressed using a match pattern: meaning, its scheme must be one of "http", "https", "file", "ftp". This means that you can't inject code into any of the browser's built-in pages, such as about:debugging, about:addons, or the page that opens when you open a new empty tab. 

*Связи между вкладками, фоновыми скриптами и частями расширения*

О, как легко мне будет работать! Я беру активную вкладку, получаю из неё адрес и заголовок, открываю новую вкладку, делаю её активной, передаю в неё адрес и заголовок и спрашиваю, добавить ли в базу данных? 

Нет простого способа передать данные во вновь открытую вкладку. 

Я думал, можно использовать метод внедрения скрипта. Оказалось, это запрещено в целях безопаности. Это можно сделать только с вкладками, которые получаются из интернета, но не с привилегированными и открытыми самим прилоежнием. 

*Сообщения*

Тогда я испробовал метод отправки сообщения. Но и тут был облом. Firefox выдал мне ошибку 
firefox sendmessage Error: Could not establish connection. Receiving end does not exist.
Error: Could not establish connection. Receiving end does not exist.

Неужели причиной стало то, что приёмник сообщения не успевал создаваться до того, как сообщение было отправлено? Но разве такое возможно? Почему бы вообще не вести очередь сообщений?

Или приёмник не находится в контексте "фонового" background скрипта, а находится в контексте страничного, внедрённого скрипта. Поэтому он не может принимать сообщения. Так что ли? Но это же чепуха. Принимать сообщения может и страничный, и фоновый скрипт.

Это навело меня на мысль, создать сразу в самом начале фонового скрипта приёмник для любых сообщений, посланных runtime.postMessage,а потом распределять их куда надо. Но вопрос. Как распределять?

Вот вменяемый ответ с stackoverflow

You get the error:

Error: Could not establish connection. Receiving end does not exist.

when you attempt to communicate (e.g. tabs.sendMessage(), tabs.connect()) to a tab where a content script is not listening for messages. This includes times when a content script does not exist in the tab.

То есть посылать сообщение в открытую вкладку - бессмысленно. Надо ждать, когда она загрузится, и тогда... Значит, надо принимать сообщение? 



*Порты*

Это чуть более продвинутая схема с сообщениями. Порты бывыют двух видов - активные и пассивные. Активные просто создаются browser.runtime и отправляют сообщения всем на свете. Пассивные создаются не так. Сперва создаётся слушатель сообщения onConnect. В него поступает порт. Я понятия не имею это тот же самые активный порт, мною созданный или другой, его копия. 

Адресация выполняется с помощью имени port.name. Слушатель события onConnect должен проверить, нужный ли ему порт и... работать с ним или не работать дальше. Никакой функции reject не существует. 

Отлаживать порты трудно, поскольку не существует инструмента, где можно посмотреть список портов и ожидателей связи с ними. 

После того, как связи установлены, порты могут обмениваться сообщениями. При этом активный и пассивный порт могут принимать и посылать соощения. 

Как было сказано выше, tabs.connect(id) не работает именно потому, что хотя вклдака уже и создана и активна, в ней не создано содержимое, не загружены скрипты и не созданы слушатели сообщеий. Поэтому связи с только что открытыми вкладками приходится обращать в обатную сторону. Фоновый скрипт ждёт сообщений от них, а не наоборот. 

Я так и не понял этой системы до конца. Как ведёт себя система, когда портов множество, когда несколько из них имеют одинаковое имя, ибо предназначены для связи с одним и тем же скриптом из других скриптов? Это одна из самых худших систем сообщений в индустрии.

*Совместимость с хром*

Разногласий 2: 

в хроме вместо browser используется chrome и вместо дурацких promise используют обычные функции-обратки. Есть и ещё какие-то мелочи. 

Имееется webextension-polyfill, который вроде как решает эту проблему, добавляя promise в  объекты Chrome. Но он работает через пень колоду. Мне было проще написать библиотеку (framework), которая обёртывает объекты и там, внтури одной-двух функций написать разные варианты для обеих систем. 


* Вкладки * 

ID вкладки зачастую строка, хотя функции, управляющие вкладками принимают число. 

Оно может меняться произвольным образом. Для слежения за ним необходимо слушать событие onUpdate. Оно одинаково во всех браузеах. Слушатель получает новое Id, объект с изменёнными свойствами и старый объект, включающий старое id. 

tabs.onUpdated

chrome.tabs.onUpdated.addListener(function callback)

callback (integer tabId, object changeInfo, Tab tab)


* VUE *

окончательно задолбал. А сначала казался почти таким же хорошим, как Дельфи. Да, с его помощью легко набросать простенький код. Но потом всё равно требуется вводить webpack. И, да,сложные вещи проще писать вручную на pure Javascript или его подобии JSX. Наш Vue умеет делать и последнее, но это воплощено в реальность столь геморроидальным способом, что проще сразу использовать React. 

Задолбало же меня созерцание неработающих шаблонов и чистых сообщений об ошибках. Возможно, причина в использованиии сжатой версии библиотеки, но я не уверен. 


* CSP - Content Security Police *

Это была последняя пуля. Штука, которая запрещает выполнение "опасных" eval, new Function (конструкторов функций), то есть вещей, которые позволяют на лету генерировать код. А также все виды таймеров. Все эти вещи есть в любой библиотеке, на них строится каждый шаблонизатор. 

script-src 'self' 'unsafe-evel'

Директива должна разрешать генерацию кода как источник скриптов. Но! Есть нюанс с понятием self. Он означает не всё расширение. Он означает только файлы html, включённые в расширение, а также фоновую страницу. Да, каждый по отдельности есть self. И это разные self.


# Избавление от страшной eval #
Ради этого пришлось установить webpack + babel + single file vue components compilator. Это было нелегко. 

Babel не компилятор. Это некая сборка модулей. Каждый модуль выполняет какую-то из функций по компиляции одной из языковых характеристик. Причём не обязательно даже javascript. Например, есть модули для react jsx. 

Модули собираются в сборки, preset. Их тоже надо устанавливать из npm. Там уже скопилась куча сборок по годам, для jsx и т.д. Наиболее популярен сейчас  babel-preset-env, который позволяет управлять другими сборками. 

Webpack это упаковщик. Он собирает кучу разных файлов в один большой файл. Это тоже сборка модулей. Некоторые модули назывюатся "загрузчики". Они сами выбирают, какие файлы им обрабатывать и выдают готовое содержимое. Так, javascript обрабатывается загрузчиком babel. Он называется babel-loader. Каждый загрузчик имеет свои опции.

Для компонентов vue нужен также загрузчик 

vue-loader, но этого мало, нужен ещё компилятор шаблонов 
vue-template-compiler

кроме этого на всякий случай поставлены 


file-loader и css-loader, которые обрабатывают обычные файлы, например, картинок и стили в разных форматах. Например, можно настроить компиляцию стилей из SUXX или как там назыается этот препроцессор. 

Наконец, 
webpack-dev-server
помогает в разработке. Он следит, не изменились ли файлы, автоматически производит перекомпиляцию и запускает браузер. Практически бесполезен при создании библиотек. 


html-webpack-plugin - я не знаю, что он делает.
extract-text-webpack-plugin - эта штука нужна вроде бы для того, чтобы извлекать стили из компонентов Вуе и собирать их в один файл стилей. 
npm install merge-files-webpack-plugin --save-dev этот плагин нужен, чтобы сливать в один файл всё, извлечённое предыдущим плагином. 

    plugins: [
        new ExtractTextPlugin({
            filename: '[name].style.css'
        }),
        new MergeFilesPlugin({
            filename: 'css/style.css',
            test: /style\.css/, // it could also be a string
            deleteSourceFiles: true
        })
Я его пока не пробовал. 
https://github.com/jtefera/merge-text-webpack        


cross-env - понятия не имею, что он делает. Надо уточнить. Кажется, позволяет создавать нечто вроед переменных среды. 

Команда построения записывается в файл package.json в секцию scripts и выглядит где-то так

    "build": "cross-env NODE_ENV=production webpack --progress --hide-modules --config webpack.lib.js"

здесь мы видим, что cross-env используется для создания переменной NODE_ENV и назначенияей значения production webpack. Это значит, что мы покончили с разработкой и вываливаем готовый продукт. Затем, уже после него идёт вызов команды webpack, которая получает разные ключи в командной строке, самый важный из которых --config. Он определяет имя файла настроек, откуда упаковщик будет брать информацию. 

Основные настройки выглядят где-то так:

  entry: './components/index.js', - точка входа

  devtool: 'inline-source-map', - бесполезная вещь    
  //параметры вывода  
  output: {
    filename: 'render.js', имя выходного файла, куда всё пакуется.
    path: path.resolve(__dirname, 'build') - путь, куда ложится файл    
	library: 'DAE', поскольку мы создаём библиотеку, ей потребуется имя 
	libraryTarget: 'umd', - способ упаковки. Я пробовал использовать 'var'. По идее он долен собрать все экспортируемые из точки входа объекты и запихнуть их в глобальную переменную. Но этого почему-то не случилось. При загрузке тестового файла выскочила ошибка, означающая, что vue не удалось создать или что-то в этом роде. Сама переменная оказалась undefined. Наверное, из-за первой ошибки. 
}


# VUE #    

Сначала он мне понравился. Можно создавать шаблоны без всяких компиляторов. Можно создавать шаблоны в компиляторах. Не нужно учить новый язык. Есть v-model, вычислимые свойства, автоматическое переключение компонентов. 

Но потом я понял, что отладка Буэ это ад. Он либо ничего не говорит, либо вываливает кучу идиотских сообщений, среди которых тонет что-то имеющее смысл. Если оно вообще есть. 

Вообще, для сложных проектов лучше не исопльзовать фреймвоки. Лучше брать простой шаблонизатор или даже писать свой. У меня где-то были наметки компилирующего шаблонизатора. Надо будет выложить. А всю бизнес логику лучше делать на чистом JavaScript. 

Это даже проще. 


Окончательно меня впечатлило такое предупреждение. 

Property or method "dynalinks" is not defined on the instance but referenced during render. Make sure to declare reactive data properties in the data option.

Объект dynalinks создаётся, передаётся в функцию, где создаётся объект Vue. Объект передаётся через props Vue. Он уже создан и заполнен данными. Объект Vue содержит много вложенных компонентов. В момент created наш dynalinks УЖЕ существует, но в props попадает undefined. 

Хватит это терпеть!

Впрочем, это была моя ошибка. Забыл заключить dynalinks:dynalinks в фигурные скобки data: {}. 

Вот теперь точно хватит это терпеть. Декларативный стиль с кучей скобок и пунктуаторов сводит меня с ума. 



# Grunt #

Откомпилировав шаблоны, я надумал наконец собрать весь хлам в один файл. К сожалению, Webpack не умеет в простую склейку файлов. Пришлось поставить grunt. Во время установки всего пакета переполнялась очередь (выскаикивало окошко queue overflow). Воистину, средства для разработки javascript говно есть. Хотя размер получился маленький, всего 100 мегабайт. К сожалению, установилась третья версия grunt-contrib-uglify. Синтаксис её настроек отличается от старой. И она зачем-то полезла в папку с компонентами vue. А вовсе не в ту папку, которую ей положено было обрабатывать. 

# Разработчики JavaScript #

Они постоянно выпускают новые версии, которые не меняют ничего, не прибавляют в производительности, не дают новых возможностей. Но зато ломают совместимость и меняют имена, форматы настроек и прочие формальные мелочи. 


# VUE #

Чем больше я на нём работаю, тем более ужасным он кажется. Идеология компонентов это хорошо, это придумали ещё в девяностые. Но как оно реализовано. Хорошо, в Vue хотя бы списки props есть,в отличие от React, где набор свойств неопредён и можно кидать в компонент разную херню. 

Но как определить, когда данные приходят в props? Часовые (watchers) срабатывают только со второго раза. Первый раз свойства устанавливаются при создании компонента. Значит, надо следить за их содержанием в конструкторе data, или в событии жизненного цикла created, которое возникает, когда компонент уже создан. Получается жуткое удвоение. Причём данные из props не участвую в отрисовке шаблона, ну, тогда за ними и следить не надо было бы.

Далее, как вообще отследить жизненный цикл компонента? Когда он создаётся? Когда рисуется? Событие mounted может быть вызвано вообще один раз за всю жизнь. С чем связано updated. А что если нам надо отследить изменения, чтобы внести другие изменения? 

Наконец, как передавать большие и сложные данные. Путь это будет перечисление огромного списка? Или один объект, могущий скрывать в себе что угодно, включая кошек Шрёдингера? Большие компоненты следует дробить на маленькие. Значит, все эти данные будут сливаться вниз, образуя каскад водопадов, подлиненне, чем Хуанхе. А как отслежвать обратные измения?

Я пытался использовать события, сделал даже event_hub для этих целей. Кстати, emit может получать данные. ДОстаточно положить в него функцию-обратку. Тогда on, получив событие, вызывает эту функцию и ложит в неё другие данные. События могут быть очень запутанными. 

Конечно, я создал EventSwitcher, Коммутатор Событий, чтобы хоть как-то упорядочить эту схему. Это всего лишь таблица команд, каждая команда имеет две части, родовую и конкретную, а также пользовательские данные. Команды можно добавлять по одной или через примесь. 

Но это очень грубое решение. Требутеся что-то более изящное. Можно использовать порты, которые встроены в WebExtension. Это будет ещё круче. Правда, они сами дерьмовое решение. Нужна какая-то связь с более точной адресацией отправителя к получателю и синхроизация протоколов взаимодейстувия, учитывая команды, отсылаемые в обе стороны. Но это потом. 

А пока я решил проблему очень просто. Пусть компоненты сами всё делают. У меня есть объект Dynalinks, который играет роль хранилища данных. Вся работа идёт через него. Это было очень предусмотрительно. Пусть же компоненты работают напрямую с ним без всяких props. Я добавил его в качестве глоабальной примести $domolink, и теперь он доступен в любом компоненте через this. 