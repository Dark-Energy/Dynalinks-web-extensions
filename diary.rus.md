*Начало*

Моя мотивация была простая. Во-первых, Mozilla обещала общее API создания расширений с Хромом. Во-вторых, вместе с удалением старых API должны были отвалиться несколько старых прилоежний, которыми я пользуюсь. Наконец, мне просто надоел мой каталог ссылок. Он жутко неудочный. Надо вручную вставлять имя и адрес странички, затем вручную сохранять файл и копировать его в нужное место. И я соблазнился сделать расширение для Firefox. Это был первый и последний раз. 

*Хранилище данных*

Первым делом мне понадобилось хранилище данных. Я думал использовать обычные файлы. 

1. Нельзя работать с файлами, нельзя читать и писать файлы из расширений. Дескать это приводит к жутким проблемам с безопасностью. Хотя в Хром это работает. 

2. Вместо этого пределагается runtime.storage, гибридный урод, плод богомерзкой связи между IndexedDB и localStorage. Он также сохраняет по ключам любую информацию, не только текст, совместимую с JSON. Но работает асинхронно. То есть после выполнения get, вы получаете в ответ promise, которому надо передать обычную функцию-обратку и ждать, пока она выполнится. В неё уже приходят извлечённые данные.

3. Обёртка данных. Когда вы ложите данные в storage по ключу, они заворачиваются в анонимный объект

set({key:value})

когда вы получаете данные по ключу, вы получаете этот самый анонимый объект

get(key).then( data => {key:value})

Нет слов,чтобы описать,сколько нервов я потратил на эту херню. 


*Открытие вкладок*

К счастью, Firefox позволяет открывать вкладки. Он, правда, делает ограничения для привилегированных вкладок, и для страниц, лежащих в самом расшиернии. Ну у меня там лежит страничка dialog.html. Я хочу её открыть во вкладке. Это всё-таки можно сделать.

Однако есть нюанс. Метод create возвращаеет promise, которое срабатывает, когда вклдака открывается. Но открывается она до того, как в неё загрузится html, css и скрипты! То есть это пустая вкладка! Имено это делает открытие вкладок бесполезным. 

*Передача данных*

Итак, ура, я нашёл активную вкладку, прочёл её адрес и заголовок. Я открыл вкладку с диалогом добавления ссылки. Теперь надо передать в неё информацию, а именно адрес и заголовок добавляемой страницы. 

К сожалению, сделать это невозможно. Кроме как использовать внедряемый скрипт. 

tabs.executeScript()

You can only inject code into pages whose URL can be expressed using a match pattern: meaning, its scheme must be one of "http", "https", "file", "ftp". This means that you can't inject code into any of the browser's built-in pages, such as about:debugging, about:addons, or the page that opens when you open a new empty tab. 

*Связи между вкладками, фоновыми скриптами и частями расширения*

О, как легко мне будет работать! Я беру активную вкладку, получаю из неё адрес и заголовок, открываю новую вкладку, делаю её активной, передаю в неё адрес и заголовок и спрашиваю, добавить ли в базу данных? 

Хуй тебе. Нет простого способа передать данные во вновь открытую вкладку. 

Я думал, можно использовать метод внедрения скрипта. Оказалось, это запрещено в целях безопаности. Это можно сделать только с вкладками, которые получаются из интернета, но не с привилегированными и открытыми самим прилоежнием. 

*Сообщения*

Тогда я испробовал метод отправки сообщения. Но и тут был облом. Firefox выдал мне ошибку 
firefox sendmessage Error: Could not establish connection. Receiving end does not exist.
Error: Could not establish connection. Receiving end does not exist.

Неужели причиной стало то, что приёмник сообщения не успевал создаваться до того, как сообщение было отправлено? Но разве такое возможно? Почему бы вообще не вести очередь сообщений?

Или приёмник не находится в контексте "фонового" background скрипта, а находится в контексте страничного, внедрённого скрипта. Поэтому он не может принимать сообщения. Так что ли? Но это же чепуха. Принимать сообщения может и страничный, и фоновый скрипт.

Это навело меня на мысль, создать сразу в самом начале фонового скрипта приёмник для любых сообщений, посланных runtime.postMessage,а потом распределять их куда надо. Но вопрос. Как распределять?

Вот вменяемый ответ с stackoverflow

You get the error:

Error: Could not establish connection. Receiving end does not exist.

when you attempt to communicate (e.g. tabs.sendMessage(), tabs.connect()) to a tab where a content script is not listening for messages. This includes times when a content script does not exist in the tab.

То есть посылать сообщение в открытую вкладку - бессмысленно. Надо ждать, когда она загрузится, и тогда... Значит, надо принимать сообщение? 

* Ужасы *

Во-первых, 

browser.runtime.onMessage.removeListener 

не всегда работает. Иногда удалённый слушатель продолжате отвечать на принятые сообщения!

Вообще, это опасный способ работы. Надо учитывать что сообщения рассылаются всем подряд, и нельяз сказать, кто именно их получит. А ведь именно он сможет послать ответ! Чтобы этого не случилось, надо слушателей настраивать на поиск и отсев именно нужного сообщения. Для того и даны три параметра:

1) сообщение в формае словаря
2) объект-отправитель, содержащий ссылку на объект-вкладку, с которой произошла отправка
3) функция-обратка.



*Порты*

Это чуть более продвинутая схема с сообщениями. Сперва создаётся порт. Об этом отправляется сообщение по всему расширению. Вопрос на миллион, кто перехватит сообщение об этом? В Firefox сообщение получают все на свете. В Chrome хуй знает. Порт имеет имя. Возможности посласть порт с неправильным именем нет. Или есть. Упоминается функция disconnect, но я не понимаю, как она действует. 

Как было сказано выше, tabs.connect(id) не работает именно потому, что хотя вклдака уже и создана и активна, в ней не создано содержимое, не загружены скрипты и не созданы слушатели сообщеий.

Остался последний способ. Добавить в открытую страничку скрипт. Который будет создавать порт с заданным именем. В фоновом скрипте, который создал вкладку, будет стоять слушатель события onConnect. 



*Совместимость с хром*

Это наглое враньё. Разногласий между ними хуева туча. Самое мелкое из них, что для доступа к API  Хром использует chrom, а Firefox объект  browser. 

Но хуже всего блядские promise. Хром вездеиспользует обычные функции-обратки, которые возвращают либо данные,либо ошибку,либо хрен знает кучу всего. 

Хотя есть webextension-polyfill, который вроде как решает эту проблему, но я понял, что он ненадёжен и некоторые вещи в нём могут не работать. У меня не получилось сделать полностью рабочее приложение Firefox рабочим в Хром. 
